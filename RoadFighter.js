function RoadFighter(canvas, w, h, z, inputBuffer) {            this.gameStarted = true;        this.RES = {		    w			: w,	//width of game screen		    h			: h,	//height of game screen		    mwp			: w*.5,	//mid-width point of road, also this is the mid-width of game screen point		    half_road_w		: 80,	//half of the width of road		    no_of_bushes	: 30,	//number of bushes or like graphics		    shift_frame_factor	: 20,	//shift the game frame by this factor		    max_bush_width	: 25,	//width of bushes or other graphics being displayed on game		    max_car_width	: 20,	//width of car graphics being displayed on game		    width_of_divider	: 10,	//width of divider		    height_of_divider	: 20,	//height of divider		    s_height_bw_divider	: 60,	//distance between two dividers (height)		    car_padding_from_b	: 10,	//left and right padding of car from road margins		    car_l_r_turn_factor	: 5,	//left and right turn factor of car		    max_car_inertia	: 15	//maximum inertia of car		    		};    this.idle = false;        this.canvas = canvas;        this.level = {		    colors : {				grass	: '#0B610B',				road	: '#333333',				divider	: '#f7f7f7'			    }		    };    this.keysPressed = inputBuffer;        this.dividerY = 0;        //note that the images loaded below must have a max width of that as set in this.RES.max_bush_width    this.bush1 = new Image();    this.bush1.src = 'img/t1.gif';    this.bush2 = new Image();    this.bush2.src = 'img/t2.gif';    this.bush3 = new Image();    this.bush3.src = 'img/t3.gif';    this.home = new Image();    this.home.src = 'img/home.gif';    this.stone = new Image();    this.stone.src = 'img/stone.gif';    this.availableGraphics = [this.bush1, this.bush2, this.bush3, this.home, this.stone];    this.bushLocations = [];	//store all the bush-like graphics locations        //note that the car image loaded below must have a max width of that as set in this.RES.max_car_width    this.car = new Image();    this.car.src = 'img/car.gif';    this.default_car_padding = {			left : 20,			bottom : 50		    };    this.carLocation = {			X : (this.RES.mwp - this.RES.half_road_w + this.default_car_padding.left),			Y : (this.RES.h - this.default_car_padding.bottom)		    };    this.inertia = 0;        this.update = function() {	if (!this.idle || this.gameStarted) {	    if (this.inertia || this.gameStarted) {		this.blank(this.RES.w, this.RES.h, this.RES.mwp, this.RES.half_road_w, this.level.colors.grass, this.level.colors.road);						var mid_of_road = this.RES.mwp;		var left_margin_of_road = mid_of_road - this.RES.half_road_w;		var right_margin_of_road = mid_of_road + this.RES.half_road_w;		var no_of_bushes = this.RES.no_of_bushes;		var shift_frame = this.RES.shift_frame_factor;				//paint the divider		this.canvas.fillStyle = this.level.colors.divider;		for (var i= this.dividerY; i< h; i+=(this.RES.height_of_divider+this.RES.s_height_bw_divider)) {		    this.canvas.fillRect( (mid_of_road) - (this.RES.width_of_divider * .5), i, this.RES.width_of_divider, this.RES.height_of_divider);		}		//shift the dividers by shift_frame factor down		this.dividerY = (this.dividerY+shift_frame)%(this.RES.height_of_divider+this.RES.s_height_bw_divider);				//paint all bushes-like graphics		var current_bush = 0, tmp_bush_x = 0;		while (current_bush < no_of_bushes) {		    if (typeof(this.bushLocations[current_bush])=='undefined') {			this.bushLocations[current_bush] = {};                                               			tmp_bush_x = getRandomInt(0, left_margin_of_road - this.RES.max_bush_width);			this.bushLocations[current_bush].X = getRandomInt(0, 1) ? tmp_bush_x : (tmp_bush_x + right_margin_of_road);			this.bushLocations[current_bush].Y = getRandomInt(0, this.RES.h);			this.bushLocations[current_bush].SRC = this.availableGraphics[getRandomInt(0, this.availableGraphics.length - 1)];// ? this.bush : this.stone;		    }		    else{			//shift the bush-like graphics by shift_frame factor down			this.bushLocations[current_bush].Y += shift_frame;			if (this.bushLocations[current_bush].Y > this.RES.h) {			    tmp_bush_x = getRandomInt(0, left_margin_of_road - this.RES.max_bush_width);			    this.bushLocations[current_bush].X = getRandomInt(0, 1) ? tmp_bush_x : (tmp_bush_x + right_margin_of_road);			    this.bushLocations[current_bush].Y = 0;			    this.bushLocations[current_bush].SRC = this.availableGraphics[getRandomInt(0, this.availableGraphics.length - 1)];// ? this.bush : this.stone;			}		    }		    		    this.canvas.drawImage(this.bushLocations[current_bush].SRC, this.bushLocations[current_bush].X, this.bushLocations[current_bush].Y);		    		    current_bush++;		}				//paint the car		this.canvas.drawImage(this.car, this.carLocation.X, this.carLocation.Y);				////Show Speed		//this.canvas.fillStyle = "#000000";	    		//this.canvas.font = "18px sans-serif";		//this.canvas.shadowOffsetX = 4;		//this.canvas.shadowOffsetY = 4;		//this.canvas.shadowColor = "#000000";		//this.canvas.shadowBlur = 8;	    		//this.canvas.fillText("SPEED : "+ ((this.inertia)*100/this.RES.max_car_inertia).toFixed(0)+ " km/hr", 10, 20);				this.gameStarted = false;	    }	    		//Show Speed		this.canvas.shadowOffsetX = 4;		this.canvas.shadowOffsetY = 4;		this.canvas.shadowColor = "#000000";		this.canvas.shadowBlur = 8;		this.canvas.fillStyle = this.level.colors.road;		this.canvas.fillRect(5, 5, (this.RES.mwp - this.RES.half_road_w + 5 ), 25);		this.canvas.fillStyle = "#ffffff";	    		this.canvas.font = "18px sans-serif";				this.canvas.fillText("SPEED : "+ ((this.inertia)*100/this.RES.max_car_inertia).toFixed(0)+ " kmph", 10, 20);	}	this.processInput();    }        this.blank = function(w, h, mwp, half_road_w, grass, road) {            	//to clear the canvas and paint left & right mud and road only		this.canvas.clearRect(0, 0, w, h);	this.canvas.fillStyle = grass;	this.canvas.fillRect(0, 0, w, h);	var grd = this.canvas.createRadialGradient(mwp, 50, 1, mwp, 50, 350);		grd.addColorStop(0, '#58595d');		grd.addColorStop(1, road);		this.canvas.fillStyle = grd;		this.canvas.fillRect((mwp - half_road_w), 0, (half_road_w * 2), h);	this.canvas.beginPath();	this.canvas.moveTo((mwp - half_road_w), 0);	this.canvas.lineTo((mwp - half_road_w), h);	this.canvas.stroke();	this.canvas.beginPath();	this.canvas.moveTo((mwp + half_road_w), 0);	this.canvas.lineTo((mwp + half_road_w), h);	this.canvas.stroke();    }        this.processInput = function() {	this.idle = true;	        if (this.keysPressed.left) {                        this.idle = false;	    trace('turning left '/*+this.inertia*/);	    if((this.inertia - 1) > 0){		this.inertia--;		this.carLocation.X = ((this.carLocation.X - this.RES.car_l_r_turn_factor) > (this.RES.mwp - this.RES.half_road_w + this.RES.car_padding_from_b)) ? (this.carLocation.X - this.RES.car_l_r_turn_factor) : this.carLocation.X;            }            else{                this.inertia = 0;            }        }	        if (this.keysPressed.right) {                        this.idle = false;	    trace('turning right '/*+this.inertia*/);	    if((this.inertia - 1) > 0){		this.inertia--;		this.carLocation.X = ((this.carLocation.X + this.RES.car_l_r_turn_factor) < (this.RES.mwp + this.RES.half_road_w - this.RES.car_padding_from_b - this.RES.max_car_width)) ? (this.carLocation.X + this.RES.car_l_r_turn_factor) : this.carLocation.X;            }            else{                this.inertia = 0;            }        }	        if (this.keysPressed.up) {                        this.idle = false;	    trace('moving forward '/*+this.inertia*/);	    this.inertia = (this.inertia + 1) <= this.RES.max_car_inertia ? (this.inertia + 1) : this.inertia;        }	        if (this.keysPressed.down) {                        this.idle = false;	    trace('moving backward '/*+this.inertia*/);	    if((this.inertia - 1) > 0){                this.inertia  -= 3;		if (this.inertia < 0) {		    this.inertia = 0;		}            }            else{                this.inertia = 0;            }	            }	        if (this.inertia && !this.keysPressed.up && !this.keysPressed.down && !this.keysPressed.left && !this.keysPressed.right) {            this.idle = false;            trace('retarding '/*+this.inertia*/);	    this.inertia = (this.inertia - 1) >= 0 ? (this.inertia - 1) : 0;        }	    };    }//function to get random number between min and maxfunction getRandomInt (min, max) {    return Math.floor(Math.random() * (max - min + 1)) + min;}